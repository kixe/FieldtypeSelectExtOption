<?php

/**
 * ProcessWire Module Fieldtype Select External Option 
 * extend all Selectfieldtypes
 * provide all Inputfields
 * 
 * pulls options (value/ label pairs) from other datatable (also other fields) 
 * access to selected datatable row via Api
 * 
 * 
 * made by kixe (Christoph Thelen) 09.03.15
 * Licensed under GNU/GPL v3
 * v 1.1.8 19.10.15
 * 
 * ProcessWire 2.x 
 * Copyright (C) 2013 by Ryan Cramer 
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 * 
 * http://processwire.com
 *
 * @todo feeding the field setting db_host with shit, produces uncatched exception from WireDatabasePDO::pdo() function.
 * provide configfields for socket
 *
 *
 *
 */

class FieldtypeSelectExtOption extends FieldtypeMulti {

	public static function getModuleInfo() {
		return array(
			'title' => 'Select External Option',
			'version' => 118,
			'summary' => __('Fieldtype which generates the options for a Select Inputfield from *any* table in *any* database hosted *anywhere*. Define database, source table, columns (to pull value & label) and the preferred Inputfieldtype in field settings.'),
			'author' => 'kixe',
			'href' => 'http://modules.processwire.com/modules/fieldtype-select-ext-option/',
			'license' => 'GNU-GPLv3',
			'hreflicense' => 'http://www.gnu.org/licenses/gpl-3.0.html',
			'icon' => 'database',
			'requires' => 'ProcessWire>=2.5.0'
		);
	}
	
	protected $database;

	/**
	 * Create a new PDO instance from field settings. set database property
	 * 
	 * 
	 * @param Field $field
	 * @return WireDatabasePDO
	 * 
	 */
	protected function setDatabase(Field $field) {
		if (!$field) $this->database= wire('database');
		if (!strlen($field->db_user.$field->db_pass.$field->db_name)) {
			$this->database = wire('database');
			return;
		}
		elseif (strlen($field->db_user) == 0 || strlen($field->db_pass) == 0 || strlen($field->db_name) == 0) {
			$this->database= wire('database');
			if (!count($_POST)) $this->error('Setting an external database failed: Missing value/s');
		}
		else {
			try	{
				$host = $field->db_host;
				$username = $field->db_user;
				$password = $field->db_pass;
				$name = $field->db_name;
				$socket = $field->db_socket; 
				$charset = wire('config')->dbCharset; // charset set in config, don't change here!
				$port =  $field->db_port; // default port set in config

				if($socket) {
					// if socket is provided ignore $host and $port and use $socket instead:
					$dsn = "mysql:unix_socket=$socket;dbname=$name;";
				} else {
					$dsn = "mysql:dbname=$name;host=$host";
					if($port) $dsn .= ";port=$port";
				}
				$driver_options = array(
					PDO::MYSQL_ATTR_INIT_COMMAND => "SET NAMES '$charset'",
					PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION
					);
				$database = new WireDatabasePDO($dsn, $username, $password, $driver_options); 
				$database->setDebugMode(wire('config')->debug);
				$this->database = $database;			
			} catch(Exception $e) {
				$this->database = wire('database');
				if (!count($_POST)) $this->error('Setting an external database failed: '.$e->getMessage());
				// return $e->getMessage();
			}
		}
	}

	/**
	 * Get an associative array of all values of the row depending to the selected single value.
	 *
	 * @param object $field
	 * @param int $value
	 * @return array / empty if column holding the values is not defined
	 *
	 */
	protected function getTableRow(Field $field, $value) {
		$this->setDatabase($field);
		$table = $field->option_table;
		if(!$table) return array();
		$columns = $this->getDatabaseColumns($table);
		$valuecolumn = $field->option_value;
		if(!in_array($valuecolumn,$columns)) return array();
		$table = $this->database->escapeTable($table);
		$value = (int)$value;
		$sql = "SELECT * FROM `$table` WHERE $valuecolumn = '$value'";
		$query = $this->database->query($sql);
		if(!$query->rowCount()) return array();
		return $query->fetch(PDO::FETCH_ASSOC); // single return, unique value
	}

	/**
	 * Access to all column values of the selected row/rows.
	 *
	 * @param string fieldname, default: first field in page of type SelectExtOption
	 * @param selector string to get a page, default: current page
	 * @return assoc array
	 *
	 */
	public function row($name = null, $selector = null) {
		$return = array();
		$n = $name;
		if ($name) $name = ',name='.$name;
		$page = ($selector)?$this->wire('pages')->get($selector):$this->wire('page');
		if ($page instanceof NullPage) throw new WireException("Page not found. Selector string '$selector' doesn't match.");
		$field = $page->fields->get('type=FieldtypeSelectExtOption'.$name);
		//field does not belong to pages fieldgroup
		if (!$name && !$field) throw new WireException("Page '$page->name' doesn't contain any field of type 'SelectExtOption'!");
		if (!$field) throw new WireException("Field '$n' doesn't belong to page '$page->name'.");

		$name = $field->name;
		$value = $page->$name;

		if ($value instanceof WireArray) foreach ($value as $key => $val) {
			$row = $this->getTableRow($field,$val->value);
			$return[$key] = $row;
		} else {
			$this->getTableRow($field,$value->value);
			$return = $this->getTableRow($field,$value->value);
		}
		return $return;
		
	}

	public function getInputfield(Page $page, Field $field) {

		// get selected values
		$v = $this->sleepValue($page,$field,$page->$field);
		// get (set default) name of Inputfieldtype
		$class = ($field->input_type)?$field->input_type:'InputfieldSelect';
		// set Inputfield
		$inputfield = $this->modules->get($class);
		// get the options array
		$options = $this->options($field);
		// populate options
		foreach($options as $optval => $label) {
			$attributes = ($v == $optval)?array('selected'=>'selected'):null;
			$inputfield->addOption($optval,$label,$attributes);
		}
		return $inputfield;
	}

	/**
	 * Get an array of all columns in a given table of the database.
	 *
	 * @param string name of the table
	 * @return array
	 *
	 */
	protected function getDatabaseColumns($table) {
		if(!in_array($table,$this->database->getTables())) return null;
		$columns = array();
		$table = $this->database->escapeTable($table);
		$sql = "SHOW COLUMNS FROM $table"; 			
		$query = $this->database->query($sql);
		if(!$query->rowCount()) return null;
		$rows = $query->fetchAll();
		foreach($rows as $row) $columns[] = $row['Field'];
		return $columns; 
		
	}

	/**
	 * Return true if column in a given table of the database is of type (int).
	 *
	 * @param string datatable and column
	 * @return null (if table and/or column doesn't exist)
	 * @return bool (true if int)
	 *
	 */
	protected function isIntColumn($table,$column) {
		$result = array();
		$columns = $this->getDatabaseColumns($table);
		if(!$columns) return null;
		if(!in_array($column,$columns)) return null;
		$table = $this->database->escapeTable($table);
		$column = $this->database->escapeCol($column);
		$sql = "SELECT DATA_TYPE FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = '$table' AND COLUMN_NAME = '$column'";
		$query = $this->database->query($sql);
		if(!$query->rowCount()) return null;
		foreach($query->fetchAll() as $type) if(strpos($type[0],'int') !== false) return true;
		return false;
	}

	/**
	 * Return array of all selectable options, key ≈ (int)optionvalue, value ≈ optionlabel
	 *
	 * @param string/int/null/object field
	 * @return array
	 *
	 */
	public function options($field = null) {
		$this->setDatabase($field);
		if (!$field instanceof Field) {
			if (is_int($field)) $selector = ",id=$field";
			elseif (is_string($field)) $selector = ",name=$field";
			$_field = $field;
			$field = wire('fields')->get('type=FieldtypeSelectExtOption'.$selector);
			if (!$field) throw new WireException("Field '$_field' doesn't exist or is not of type FieldtypeSelectExtOption.");
		}
		elseif ($field->type != 'FieldtypeSelectExtOption') throw new WireException("Expecting FieldtypeSelectExtOption.");
		// create options array
		$options = $this->getExtOptions($field->option_table,$field->option_value,$field->option_label,$this->filter($field),$field->option_order,$field->option_asc);
		return ($options)?$options:array(0 => 'no data');
	}

	/**
	 * Get options array from external field or datatable
	 *
	 * @return bool false if table and/or column doesn't exist
	 * @return null if table doesn't contain any data
	 * @return array(value => label)
	 *
	 */
	protected function getExtOptions($table, $value = false, $label = false, $filter= false, $order = false, $dir = false) {

		// check if table exist
		$table = $this->database->escapeTable($table);
		if(!in_array($table,$this->database->getTables())) return false;

		// get columns array
		$columns = $this->getDatabaseColumns($table);

		// we need minimum one inttype column 
		foreach ($columns as $column) {
			if ($this->isIntColumn($table,$column)) $intcolumn = $column; break;
		}
		if (!isset($intcolumn)) return false;

		// check if column isset and exist, default 1st column
		if($label === false) $label = $columns[0];
		else if(!in_array($label,$columns))return false;

		// check if column isset and exist, default 1st column of type int
		if($value === false) $value = $intcolumn;
		else if(!in_array($value,$columns))return false;

		$options = array();
		
		$dir = ((bool)$dir)?'DESC':'ASC';
		$order = ($order)?$order:$label;
		$order = $this->database->escapeCol($order);
		// validate/sanitize filterstring
		$filter = ($filter)?"WHERE $filter":'';
		$query = $this->database->prepare("SELECT * FROM `$table` $filter ORDER BY `$order` $dir");
		$query->execute();
		if(!$query->rowCount()) return null;
        	while($row = $query->fetch(PDO::FETCH_ASSOC)) $options[$row[$value]] = $row[$label];
        	return $options;
	}

	protected function ___filter(Field $field) {
		// all parts set?
		if(!$field->filter_column||!$field->filter_selector||!$field->filter_value) return false;
		// valid operator?
		$operators = array(' LIKE ',' NOT LIKE ');
		if(!$this->database->isOperator($field->filter_selector) && !in_array($field->filter_selector,$operators))  return false;
		// escape column, quote value,
		return '`'.$this->database->escapeCol($field->filter_column).'`'.$field->filter_selector.$this->database->quote($field->filter_value);
	}

	public function getBlankValue(Page $page, Field $field) {
		return (!$field->input_type)?new SelectExtOption():new WireArray();
	}

	public function getSingleValue(Field $field, $value) {
		$new = new SelectExtOption();
		$new->value = ($value !== null)?(int)$value:null;	
		$row = $this->getTableRow($field,$new->value);
		if (!$row) return new SelectExtOption();
		foreach ($row as $key => $value) {
			// skip reserved words
			if (in_array($key,array('value','label','row','data','options'))) continue;
			$new->set($key,$value);
		}
		$new->row = $row;
		$new->options = $this->options($field);
		$new->label = $field->option_label?$row[$field->option_label]:reset($row);
		return $new;
	}

	public function sanitizeValue(Page $page, Field $field, $value) {
		if($value instanceof SelectExtOption) return $value;
		if($value instanceof WireArray) return $value;
		if(!$value) return $this->getBlankValue($page,$field);
		if(is_string($value)) return $this->getSingleValue($field,$value);
		$return = new WireArray();
		foreach ($value as $val) $return->add($this->getSingleValue($field,$val));
		return $return;
	}

	public function wakeupValue(Page $page, Field $field, $value) {
		if(!$value) return $this->getBlankValue($page,$field);
		$module = $this->modules->get($field->input_type);
		if(!$module instanceof InputfieldHasArrayValue) return $this->getSingleValue($field,array_pop($value));
		$return = new WireArray();
		foreach ($value as $val) $return->set($val,$this->getSingleValue($field,$val));
		$return->data('options',$this->options($field));
		return $return;
	}

	public function sleepValue(Page $page, Field $field, $value) {
		if($value instanceof SelectExtOption) return ($value->value)?array($value->value):null;
		$return = array();
		if($value instanceof WireArray) {
	 		foreach ($value as $object) {
		    	if(!$object instanceof SelectExtOption) throw new WireException("Expecting an instance of SelectExtOption");
		    	if ($object->value === null) continue;
				$return[] = $object->value;
			}
		}
		return $return;
	}
	
	public function ___getConfigInputfields(Field $field) {

		$this->setDatabase($field);
		$inputfields = parent::___getConfigInputfields($field);

		// usage
		$markup = file_exists(dirname(__FILE__) . '/README.md')?file_get_contents(dirname(__FILE__) . '/README.md'):null;
		if ($markup) {
			$f = $this->modules->get("InputfieldMarkup");
			$f->label = _('Usage');
			// call textformatter before wrapping
			$this->modules->get('TextformatterMarkdownExtra')->format($markup); 
			$f->markupText = "<div style=\"padding:0 16px; border-left: 16px solid #29c4bc;\"><strong>README.md</strong><hr/>$markup</div>";
			$f->collapsed = Inputfield::collapsedYes;
			$inputfields->append($f);
		}

		// choose inputfieldtype
		$f = $this->modules->get('InputfieldSelect');
		$f->label = _('Inputfieldtype');
		$f->attr('name', 'input_type');
		$f->attr('value', $field->input_type);
		$f->required = true;
		$f->description = $this->_('Select the type of Inputfield.');
		$f->notes = '* ' . $this->_('Types indicated with an asterisk are for multiple selection. Maybe 3rd party Inputfields will not work as expected. Please test carefully.');
		$f->addOption('InputfieldSelect', 'Select');
		foreach($this->modules->get("InputfieldPage")->data['inputfieldClasses'] as $class) {
			$module = $this->modules->get($class);
			if(is_subclass_of($module, 'InputfieldSelect')) {
				$label = str_replace("Inputfield", '', $class);
				if($module instanceof InputfieldHasArrayValue) $label .= "*";
				$f->addOption($class, $label);
			}
		}
		$inputfields->append($f);

		// external Database
		$fieldset = $this->modules->get("InputfieldFieldset");
		$fieldset->label = _('External MySQL Database/ Host');
		$fieldset->description = _("Optionally specify an external MySQL 5.x database. If the database is not accessible for any reason default database will be selected.");
		$fieldset->notes = _('Incorrect entries in the field \'DB Host\' produce unsightly error messages! Be aware of this.');
		$fieldset->collapsed = Inputfield::collapsedYes;
		$inputfields->add($fieldset);

		// DB Name
		$f = $this->modules->get("InputfieldText");
		$f->label = _("DB Name");
		$f->attr('name', 'db_name');
		$f->attr('value', $field->db_name);
		$f->columnWidth = 20;
		$fieldset->append($f);

		// DB User
		$f = $this->modules->get("InputfieldText");
		$f->label = _("DB User");
		$f->attr('name', 'db_user');
		$f->attr('value', $field->db_user);
		$f->columnWidth = 20;
		$fieldset->append($f);

		// DB Pass
		$f = $this->modules->get("InputfieldText");
		$f->label = _("DB Pass");
		$f->attr('name', 'db_pass');
		$f->attr('value', $field->db_pass);
		$f->columnWidth = 20;
		$fieldset->append($f);

		// DB Host
		$f = $this->modules->get("InputfieldText");
		$f->label = _("DB Host");
		$f->attr('name', 'db_host');
		$host = (isset($field->db_host))?$field->db_host:'localhost';
		$f->attr('value', $host);
		$f->columnWidth = 20;
		$fieldset->append($f);

		/*
		// DB Socket
		$f = $this->modules->get("InputfieldText");
		$f->label = _("Socket");
		$f->attr('name', 'db_socket');
		$f->attr('value', $field->db_socket);
		$f->columnWidth = 16.666;
		$fieldset->append($f);
		*/

		// DB Port
		$f = $this->modules->get("InputfieldText");
		$f->label = _("DB Port");
		$f->attr('name', 'db_port');
		($field->db_port)?$f->attr('value', $field->db_port):wire('config')->dbPort;
		$f->columnWidth = 20;
		$fieldset->append($f);

		// create options
		$fieldset = $this->modules->get("InputfieldFieldset");
		$fieldset->label = _('Create options from any database table');
		$fieldset->notes = _("Save after selecting 'Source Table' to populate the appropriate select for 'Option Label' and 'Option Value'. Make a selection and save again.");
		$inputfields->add($fieldset);

		// source table
		$f = $this->modules->get("InputfieldSelect");
		$f->label = _("Source Table");
		$f->attr('name', 'option_table');
		$f->required = true;
		$f->attr('value', $field->option_table);
		if (!$field->option_table) $f->addOption(null, 'no table selected!',array('selected'=>'selected'));
		if ($this->getExtOptions($field->option_table) === null && !count($_POST)) $f->error('Table doesn\'t contain any data!');
		foreach ($this->database->getTables() as $table) $f->addOption($table, $table);
		$f->description = _("Choose a table in your database.");
		$f->columnWidth = 33;
		$fieldset->append($f);

		$columns = $this->getDatabaseColumns($field->option_table);
		// option value column
		$f = $this->modules->get("InputfieldSelect");
		$f->label = _("Option Value");
		$f->attr('name', 'option_value');
		$f->attr('value', $field->option_value);
		$f->description = _("Choose an integer type column.");
		if ($columns) foreach ($columns as $value) {
			if ($this->isIntColumn($field->option_table,$value)) $f->addOption($value, $value);
		}
		if ($field->option_table && !count($f->getOptions()) && !count($_POST)) $f->error("Only tables with columns of type 'integer' allowed!");
		if (!$field->option_value) $f->addOption(null, 'no column selected!',array('selected'=>'selected'));		
		$f->columnWidth = 34; 
		$fieldset->append($f);

		// option label column
		$f = $this->modules->get("InputfieldSelect");
		$f->label = _("Option Label");
		$f->attr('name', 'option_label');
		$f->attr('value', $field->option_label);
		$f->description = _("Choose from all columns.");
		if (!$field->option_label) $f->addOption(null, 'no column selected!',array('selected'=>'selected'));
		if ($columns) foreach ($columns as $label) $f->addOption($label, $label);
		$f->columnWidth = 33; 
		$fieldset->append($f);

		// option filter
		$fieldset = $this->modules->get("InputfieldFieldset");
		$fieldset->label = _('Filter');
		$fieldset->description = _("Configure to limit the option list.");
		$fc=($field->filter_column)?$field->filter_column:'[Column]';
		$fs=($field->filter_selector)?$field->filter_selector:'[Selector Operator]';
		$fv=($field->filter_value)?$field->filter_value:'[Value]';
		$fieldset->notes = _("SELECT * FROM $field->option_table WHERE $fc$fs'$fv'");
		$fieldset->collapsed = Inputfield::collapsedBlank;
		$fieldset->showIf = "option_value!=''";
		$inputfields->add($fieldset);

		// filter column
		$f = $this->modules->get("InputfieldSelect");
		$f->label = _("Column");
		$f->attr('name', 'filter_column');
		$f->attr('value', $field->filter_column);
		if ($columns) foreach ($columns as $filtercol) $f->addOption($filtercol, $filtercol);
		$f->columnWidth = 33; 
		$fieldset->append($f);

		// filter selector
		$f = $this->modules->get("InputfieldSelect");
		$f->label = _("Selector Operator");
		$f->attr('name', 'filter_selector');
		$f->attr('value', $field->filter_selector);
		$selectors = array('=', '<', '>', '>=', '<=', '<>', '!=', ' LIKE ',' NOT LIKE ');
		foreach ($selectors as $selector) $f->addOption($selector, $selector);
		$f->columnWidth = 34; 
		$fieldset->append($f);

		// filter value
		$f = $this->modules->get("InputfieldText");
		$f->label = _("Value");
		$f->attr('name', 'filter_value');
		$f->attr('value', $field->filter_value);
		$f->columnWidth = 33; 
		$fieldset->append($f);

		// option orderby
		$f = $this->modules->get("InputfieldSelect");
		$f->label = _("Order by");
		$f->description = _("Default: Order by label");
		$f->attr('name', 'option_order');
		$f->attr('value', $field->option_order);
		if ($columns) foreach ($columns as $ordercol) {
			if ($ordercol == $field->option_label) continue;
			$f->addOption($ordercol, $ordercol);
		}
		$f->collapsed = Inputfield::collapsedYes;
		$f->showIf = "option_value!=''";
		$inputfields->append($f);

		// option order asc/ desc
		$f = $this->modules->get("InputfieldRadios");
		$f->label = _("Order Direction");
		$f->attr('name', 'option_asc');
		($field->option_asc)?$f->attr('value', $field->option_asc):$f->attr('value', 0);
		$f->addOption(0,"Ascending");
		$f->addOption(1,"Descending");
		$f->collapsed = Inputfield::collapsedYes;
		$f->showIf = "option_value!=''";
		$inputfields->append($f);

		return $inputfields;
	}
}

/**
* Helper WireData Class to hold a SelectExtOption object
*
*/
class SelectExtOption extends WireData {

	/**
	 * Array where get/set properties are stored
	 *
	 */
	protected $data = array();

	public function __construct() {
		$this->set('value', null);
		$this->set('label', null);
		$this->set('row', array());
		$this->set('options', array());
	}

	public function set($key, $value) {
		if(in_array($key,array('value','label','row','data','options'))) {
			if($key == 'data') throw new WireException("'data' property is reserved by WireData class. (array where get/set properties are stored)");
			// validation of label ? 
			if($key == 'value' && !is_null($value) && !is_int($value)) throw new WireException("SelectExtOption object only accepts integer (int) as value property");
			if($key == ('row'|'options') && !is_array($value)) throw new WireException("SelectExtOption object only accepts arrays as '$key' property");
		}
		return parent::set($key, $value);
	}

	public function get($key) {
		return parent::get($key);
	}

	// magic patch by teppo replaces hook
	public function __toString() {
		return (string) $this->value;
    }
}
